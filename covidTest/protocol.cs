// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: test.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
/// <summary>Holder for reflection information generated from test.proto</summary>
public static partial class TestReflection
{

    #region Descriptor
    /// <summary>File descriptor for test.proto</summary>
    public static pbr::FileDescriptor Descriptor
    {
        get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static TestReflection()
    {
        byte[] descriptorData = global::System.Convert.FromBase64String(
            string.Concat(
              "Cgp0ZXN0LnByb3RvIv4BChpUZW1wb3JhcnlFeHBvc3VyZUtleUV4cG9ydBIX",
              "Cg9zdGFydF90aW1lc3RhbXAYASABKAYSFQoNZW5kX3RpbWVzdGFtcBgCIAEo",
              "BhIOCgZyZWdpb24YAyABKAkSEQoJYmF0Y2hfbnVtGAQgASgFEhIKCmJhdGNo",
              "X3NpemUYBSABKAUSJwoPc2lnbmF0dXJlX2luZm9zGAYgAygLMg4uU2lnbmF0",
              "dXJlSW5mbxIjCgRrZXlzGAcgAygLMhUuVGVtcG9yYXJ5RXhwb3N1cmVLZXkS",
              "KwoMcmV2aXNlZF9rZXlzGAggAygLMhUuVGVtcG9yYXJ5RXhwb3N1cmVLZXki",
              "lwEKDVNpZ25hdHVyZUluZm8SIAoYdmVyaWZpY2F0aW9uX2tleV92ZXJzaW9u",
              "GAMgASgJEhsKE3ZlcmlmaWNhdGlvbl9rZXlfaWQYBCABKAkSGwoTc2lnbmF0",
              "dXJlX2FsZ29yaXRobRgFIAEoCUoECAEQAkoECAIQA1INYXBwX2J1bmRsZV9p",
              "ZFIPYW5kcm9pZF9wYWNrYWdlIuwCChRUZW1wb3JhcnlFeHBvc3VyZUtleRIQ",
              "CghrZXlfZGF0YRgBIAEoDBIjChd0cmFuc21pc3Npb25fcmlza19sZXZlbBgC",
              "IAEoBUICGAESJQodcm9sbGluZ19zdGFydF9pbnRlcnZhbF9udW1iZXIYAyAB",
              "KAUSGwoOcm9sbGluZ19wZXJpb2QYBCABKAU6AzE0NBI1CgtyZXBvcnRfdHlw",
              "ZRgFIAEoDjIgLlRlbXBvcmFyeUV4cG9zdXJlS2V5LlJlcG9ydFR5cGUSJAoc",
              "ZGF5c19zaW5jZV9vbnNldF9vZl9zeW1wdG9tcxgGIAEoESJ8CgpSZXBvcnRU",
              "eXBlEgsKB1VOS05PV04QABISCg5DT05GSVJNRURfVEVTVBABEiAKHENPTkZJ",
              "Uk1FRF9DTElOSUNBTF9ESUFHTk9TSVMQAhIPCgtTRUxGX1JFUE9SVBADEg0K",
              "CVJFQ1VSU0lWRRAEEgsKB1JFVk9LRUQQBQ=="));
        descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
            new pbr::FileDescriptor[] { },
            new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
          new pbr::GeneratedClrTypeInfo(typeof(global::TemporaryExposureKeyExport), global::TemporaryExposureKeyExport.Parser, new[]{ "StartTimestamp", "EndTimestamp", "Region", "BatchNum", "BatchSize", "SignatureInfos", "Keys", "RevisedKeys" }, null, null, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(global::SignatureInfo), global::SignatureInfo.Parser, new[]{ "VerificationKeyVersion", "VerificationKeyId", "SignatureAlgorithm" }, null, null, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(global::TemporaryExposureKey), global::TemporaryExposureKey.Parser, new[]{ "KeyData", "TransmissionRiskLevel", "RollingStartIntervalNumber", "RollingPeriod", "ReportType", "DaysSinceOnsetOfSymptoms" }, null, new[]{ typeof(global::TemporaryExposureKey.Types.ReportType) }, null, null)
            }));
    }
    #endregion

}
#region Messages
public sealed partial class TemporaryExposureKeyExport : pb::IMessage<TemporaryExposureKeyExport>
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    , pb::IBufferMessage
#endif
{
    private static readonly pb::MessageParser<TemporaryExposureKeyExport> _parser = new pb::MessageParser<TemporaryExposureKeyExport>(() => new TemporaryExposureKeyExport());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TemporaryExposureKeyExport> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor
    {
        get { return global::TestReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor
    {
        get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TemporaryExposureKeyExport()
    {
        OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TemporaryExposureKeyExport(TemporaryExposureKeyExport other) : this()
    {
        _hasBits0 = other._hasBits0;
        startTimestamp_ = other.startTimestamp_;
        endTimestamp_ = other.endTimestamp_;
        region_ = other.region_;
        batchNum_ = other.batchNum_;
        batchSize_ = other.batchSize_;
        signatureInfos_ = other.signatureInfos_.Clone();
        keys_ = other.keys_.Clone();
        revisedKeys_ = other.revisedKeys_.Clone();
        _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TemporaryExposureKeyExport Clone()
    {
        return new TemporaryExposureKeyExport(this);
    }

    /// <summary>Field number for the "start_timestamp" field.</summary>
    public const int StartTimestampFieldNumber = 1;
    private readonly static ulong StartTimestampDefaultValue = 0UL;

    private ulong startTimestamp_;
    /// <summary>
    /// Time window of keys in the file, based on arrival
    /// at the server, in UTC seconds.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong StartTimestamp
    {
        get { if ((_hasBits0 & 1) != 0) { return startTimestamp_; } else { return StartTimestampDefaultValue; } }
        set
        {
            _hasBits0 |= 1;
            startTimestamp_ = value;
        }
    }
    /// <summary>Gets whether the "start_timestamp" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasStartTimestamp
    {
        get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "start_timestamp" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearStartTimestamp()
    {
        _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "end_timestamp" field.</summary>
    public const int EndTimestampFieldNumber = 2;
    private readonly static ulong EndTimestampDefaultValue = 0UL;

    private ulong endTimestamp_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong EndTimestamp
    {
        get { if ((_hasBits0 & 2) != 0) { return endTimestamp_; } else { return EndTimestampDefaultValue; } }
        set
        {
            _hasBits0 |= 2;
            endTimestamp_ = value;
        }
    }
    /// <summary>Gets whether the "end_timestamp" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasEndTimestamp
    {
        get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "end_timestamp" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearEndTimestamp()
    {
        _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "region" field.</summary>
    public const int RegionFieldNumber = 3;
    private readonly static string RegionDefaultValue = "";

    private string region_;
    /// <summary>
    /// The region from which these keys came
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Region
    {
        get { return region_ ?? RegionDefaultValue; }
        set
        {
            region_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        }
    }
    /// <summary>Gets whether the "region" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasRegion
    {
        get { return region_ != null; }
    }
    /// <summary>Clears the value of the "region" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearRegion()
    {
        region_ = null;
    }

    /// <summary>Field number for the "batch_num" field.</summary>
    public const int BatchNumFieldNumber = 4;
    private readonly static int BatchNumDefaultValue = 0;

    private int batchNum_;
    /// <summary>
    /// Reserved for future use. Both batch_num and batch_size
    /// must be set to a value of 1.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int BatchNum
    {
        get { if ((_hasBits0 & 4) != 0) { return batchNum_; } else { return BatchNumDefaultValue; } }
        set
        {
            _hasBits0 |= 4;
            batchNum_ = value;
        }
    }
    /// <summary>Gets whether the "batch_num" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasBatchNum
    {
        get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "batch_num" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearBatchNum()
    {
        _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "batch_size" field.</summary>
    public const int BatchSizeFieldNumber = 5;
    private readonly static int BatchSizeDefaultValue = 0;

    private int batchSize_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int BatchSize
    {
        get { if ((_hasBits0 & 8) != 0) { return batchSize_; } else { return BatchSizeDefaultValue; } }
        set
        {
            _hasBits0 |= 8;
            batchSize_ = value;
        }
    }
    /// <summary>Gets whether the "batch_size" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasBatchSize
    {
        get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "batch_size" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearBatchSize()
    {
        _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "signature_infos" field.</summary>
    public const int SignatureInfosFieldNumber = 6;
    private static readonly pb::FieldCodec<global::SignatureInfo> _repeated_signatureInfos_codec
        = pb::FieldCodec.ForMessage(50, global::SignatureInfo.Parser);
    private readonly pbc::RepeatedField<global::SignatureInfo> signatureInfos_ = new pbc::RepeatedField<global::SignatureInfo>();
    /// <summary>
    /// Information about associated signatures
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::SignatureInfo> SignatureInfos
    {
        get { return signatureInfos_; }
    }

    /// <summary>Field number for the "keys" field.</summary>
    public const int KeysFieldNumber = 7;
    private static readonly pb::FieldCodec<global::TemporaryExposureKey> _repeated_keys_codec
        = pb::FieldCodec.ForMessage(58, global::TemporaryExposureKey.Parser);
    private readonly pbc::RepeatedField<global::TemporaryExposureKey> keys_ = new pbc::RepeatedField<global::TemporaryExposureKey>();
    /// <summary>
    /// Exposure keys that are new. 
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::TemporaryExposureKey> Keys
    {
        get { return keys_; }
    }

    /// <summary>Field number for the "revised_keys" field.</summary>
    public const int RevisedKeysFieldNumber = 8;
    private static readonly pb::FieldCodec<global::TemporaryExposureKey> _repeated_revisedKeys_codec
        = pb::FieldCodec.ForMessage(66, global::TemporaryExposureKey.Parser);
    private readonly pbc::RepeatedField<global::TemporaryExposureKey> revisedKeys_ = new pbc::RepeatedField<global::TemporaryExposureKey>();
    /// <summary>
    /// Keys that have changed status from previous key archives,
    /// including keys that are being revoked.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::TemporaryExposureKey> RevisedKeys
    {
        get { return revisedKeys_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other)
    {
        return Equals(other as TemporaryExposureKeyExport);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TemporaryExposureKeyExport other)
    {
        if (ReferenceEquals(other, null))
        {
            return false;
        }
        if (ReferenceEquals(other, this))
        {
            return true;
        }
        if (StartTimestamp != other.StartTimestamp) return false;
        if (EndTimestamp != other.EndTimestamp) return false;
        if (Region != other.Region) return false;
        if (BatchNum != other.BatchNum) return false;
        if (BatchSize != other.BatchSize) return false;
        if (!signatureInfos_.Equals(other.signatureInfos_)) return false;
        if (!keys_.Equals(other.keys_)) return false;
        if (!revisedKeys_.Equals(other.revisedKeys_)) return false;
        return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode()
    {
        int hash = 1;
        if (HasStartTimestamp) hash ^= StartTimestamp.GetHashCode();
        if (HasEndTimestamp) hash ^= EndTimestamp.GetHashCode();
        if (HasRegion) hash ^= Region.GetHashCode();
        if (HasBatchNum) hash ^= BatchNum.GetHashCode();
        if (HasBatchSize) hash ^= BatchSize.GetHashCode();
        hash ^= signatureInfos_.GetHashCode();
        hash ^= keys_.GetHashCode();
        hash ^= revisedKeys_.GetHashCode();
        if (_unknownFields != null)
        {
            hash ^= _unknownFields.GetHashCode();
        }
        return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString()
    {
        return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output)
    {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        output.WriteRawMessage(this);
#else
    if (HasStartTimestamp) {
      output.WriteRawTag(9);
      output.WriteFixed64(StartTimestamp);
    }
    if (HasEndTimestamp) {
      output.WriteRawTag(17);
      output.WriteFixed64(EndTimestamp);
    }
    if (HasRegion) {
      output.WriteRawTag(26);
      output.WriteString(Region);
    }
    if (HasBatchNum) {
      output.WriteRawTag(32);
      output.WriteInt32(BatchNum);
    }
    if (HasBatchSize) {
      output.WriteRawTag(40);
      output.WriteInt32(BatchSize);
    }
    signatureInfos_.WriteTo(output, _repeated_signatureInfos_codec);
    keys_.WriteTo(output, _repeated_keys_codec);
    revisedKeys_.WriteTo(output, _repeated_revisedKeys_codec);
    if (_unknownFields != null) {
      _unknownFields.WriteTo(output);
    }
#endif
    }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output)
    {
        if (HasStartTimestamp)
        {
            output.WriteRawTag(9);
            output.WriteFixed64(StartTimestamp);
        }
        if (HasEndTimestamp)
        {
            output.WriteRawTag(17);
            output.WriteFixed64(EndTimestamp);
        }
        if (HasRegion)
        {
            output.WriteRawTag(26);
            output.WriteString(Region);
        }
        if (HasBatchNum)
        {
            output.WriteRawTag(32);
            output.WriteInt32(BatchNum);
        }
        if (HasBatchSize)
        {
            output.WriteRawTag(40);
            output.WriteInt32(BatchSize);
        }
        signatureInfos_.WriteTo(ref output, _repeated_signatureInfos_codec);
        keys_.WriteTo(ref output, _repeated_keys_codec);
        revisedKeys_.WriteTo(ref output, _repeated_revisedKeys_codec);
        if (_unknownFields != null)
        {
            _unknownFields.WriteTo(ref output);
        }
    }
#endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize()
    {
        int size = 0;
        if (HasStartTimestamp)
        {
            size += 1 + 8;
        }
        if (HasEndTimestamp)
        {
            size += 1 + 8;
        }
        if (HasRegion)
        {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Region);
        }
        if (HasBatchNum)
        {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(BatchNum);
        }
        if (HasBatchSize)
        {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(BatchSize);
        }
        size += signatureInfos_.CalculateSize(_repeated_signatureInfos_codec);
        size += keys_.CalculateSize(_repeated_keys_codec);
        size += revisedKeys_.CalculateSize(_repeated_revisedKeys_codec);
        if (_unknownFields != null)
        {
            size += _unknownFields.CalculateSize();
        }
        return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TemporaryExposureKeyExport other)
    {
        if (other == null)
        {
            return;
        }
        if (other.HasStartTimestamp)
        {
            StartTimestamp = other.StartTimestamp;
        }
        if (other.HasEndTimestamp)
        {
            EndTimestamp = other.EndTimestamp;
        }
        if (other.HasRegion)
        {
            Region = other.Region;
        }
        if (other.HasBatchNum)
        {
            BatchNum = other.BatchNum;
        }
        if (other.HasBatchSize)
        {
            BatchSize = other.BatchSize;
        }
        signatureInfos_.Add(other.signatureInfos_);
        keys_.Add(other.keys_);
        revisedKeys_.Add(other.revisedKeys_);
        _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input)
    {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        input.ReadRawMessage(this);
#else
    uint tag;
    while ((tag = input.ReadTag()) != 0) {
      switch(tag) {
        default:
          _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
          break;
        case 9: {
          StartTimestamp = input.ReadFixed64();
          break;
        }
        case 17: {
          EndTimestamp = input.ReadFixed64();
          break;
        }
        case 26: {
          Region = input.ReadString();
          break;
        }
        case 32: {
          BatchNum = input.ReadInt32();
          break;
        }
        case 40: {
          BatchSize = input.ReadInt32();
          break;
        }
        case 50: {
          signatureInfos_.AddEntriesFrom(input, _repeated_signatureInfos_codec);
          break;
        }
        case 58: {
          keys_.AddEntriesFrom(input, _repeated_keys_codec);
          break;
        }
        case 66: {
          revisedKeys_.AddEntriesFrom(input, _repeated_revisedKeys_codec);
          break;
        }
      }
    }
#endif
    }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input)
    {
        uint tag;
        while ((tag = input.ReadTag()) != 0)
        {
            switch (tag)
            {
                default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                case 9:
                    {
                        StartTimestamp = input.ReadFixed64();
                        break;
                    }
                case 17:
                    {
                        EndTimestamp = input.ReadFixed64();
                        break;
                    }
                case 26:
                    {
                        Region = input.ReadString();
                        break;
                    }
                case 32:
                    {
                        BatchNum = input.ReadInt32();
                        break;
                    }
                case 40:
                    {
                        BatchSize = input.ReadInt32();
                        break;
                    }
                case 50:
                    {
                        signatureInfos_.AddEntriesFrom(ref input, _repeated_signatureInfos_codec);
                        break;
                    }
                case 58:
                    {
                        keys_.AddEntriesFrom(ref input, _repeated_keys_codec);
                        break;
                    }
                case 66:
                    {
                        revisedKeys_.AddEntriesFrom(ref input, _repeated_revisedKeys_codec);
                        break;
                    }
            }
        }
    }
#endif

}

public sealed partial class SignatureInfo : pb::IMessage<SignatureInfo>
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    , pb::IBufferMessage
#endif
{
    private static readonly pb::MessageParser<SignatureInfo> _parser = new pb::MessageParser<SignatureInfo>(() => new SignatureInfo());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SignatureInfo> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor
    {
        get { return global::TestReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor
    {
        get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SignatureInfo()
    {
        OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SignatureInfo(SignatureInfo other) : this()
    {
        verificationKeyVersion_ = other.verificationKeyVersion_;
        verificationKeyId_ = other.verificationKeyId_;
        signatureAlgorithm_ = other.signatureAlgorithm_;
        _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SignatureInfo Clone()
    {
        return new SignatureInfo(this);
    }

    /// <summary>Field number for the "verification_key_version" field.</summary>
    public const int VerificationKeyVersionFieldNumber = 3;
    private readonly static string VerificationKeyVersionDefaultValue = "";

    private string verificationKeyVersion_;
    /// <summary>
    /// Key version in case the EN server signing key is rotated. (e.g. "v1")
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string VerificationKeyVersion
    {
        get { return verificationKeyVersion_ ?? VerificationKeyVersionDefaultValue; }
        set
        {
            verificationKeyVersion_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        }
    }
    /// <summary>Gets whether the "verification_key_version" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasVerificationKeyVersion
    {
        get { return verificationKeyVersion_ != null; }
    }
    /// <summary>Clears the value of the "verification_key_version" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearVerificationKeyVersion()
    {
        verificationKeyVersion_ = null;
    }

    /// <summary>Field number for the "verification_key_id" field.</summary>
    public const int VerificationKeyIdFieldNumber = 4;
    private readonly static string VerificationKeyIdDefaultValue = "";

    private string verificationKeyId_;
    /// <summary>
    /// Implementation-specific string that can be used in key verification.
    /// Valid character in this string are all alphanumeric characters, 
    /// underscores, and periods.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string VerificationKeyId
    {
        get { return verificationKeyId_ ?? VerificationKeyIdDefaultValue; }
        set
        {
            verificationKeyId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        }
    }
    /// <summary>Gets whether the "verification_key_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasVerificationKeyId
    {
        get { return verificationKeyId_ != null; }
    }
    /// <summary>Clears the value of the "verification_key_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearVerificationKeyId()
    {
        verificationKeyId_ = null;
    }

    /// <summary>Field number for the "signature_algorithm" field.</summary>
    public const int SignatureAlgorithmFieldNumber = 5;
    private readonly static string SignatureAlgorithmDefaultValue = "";

    private string signatureAlgorithm_;
    /// <summary>
    /// All keys must be signed using the SHA-256 with ECDSA algorithm.
    /// This field must contain the string "1.2.840.10045.4.3.2". 
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string SignatureAlgorithm
    {
        get { return signatureAlgorithm_ ?? SignatureAlgorithmDefaultValue; }
        set
        {
            signatureAlgorithm_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        }
    }
    /// <summary>Gets whether the "signature_algorithm" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSignatureAlgorithm
    {
        get { return signatureAlgorithm_ != null; }
    }
    /// <summary>Clears the value of the "signature_algorithm" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSignatureAlgorithm()
    {
        signatureAlgorithm_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other)
    {
        return Equals(other as SignatureInfo);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SignatureInfo other)
    {
        if (ReferenceEquals(other, null))
        {
            return false;
        }
        if (ReferenceEquals(other, this))
        {
            return true;
        }
        if (VerificationKeyVersion != other.VerificationKeyVersion) return false;
        if (VerificationKeyId != other.VerificationKeyId) return false;
        if (SignatureAlgorithm != other.SignatureAlgorithm) return false;
        return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode()
    {
        int hash = 1;
        if (HasVerificationKeyVersion) hash ^= VerificationKeyVersion.GetHashCode();
        if (HasVerificationKeyId) hash ^= VerificationKeyId.GetHashCode();
        if (HasSignatureAlgorithm) hash ^= SignatureAlgorithm.GetHashCode();
        if (_unknownFields != null)
        {
            hash ^= _unknownFields.GetHashCode();
        }
        return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString()
    {
        return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output)
    {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        output.WriteRawMessage(this);
#else
    if (HasVerificationKeyVersion) {
      output.WriteRawTag(26);
      output.WriteString(VerificationKeyVersion);
    }
    if (HasVerificationKeyId) {
      output.WriteRawTag(34);
      output.WriteString(VerificationKeyId);
    }
    if (HasSignatureAlgorithm) {
      output.WriteRawTag(42);
      output.WriteString(SignatureAlgorithm);
    }
    if (_unknownFields != null) {
      _unknownFields.WriteTo(output);
    }
#endif
    }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output)
    {
        if (HasVerificationKeyVersion)
        {
            output.WriteRawTag(26);
            output.WriteString(VerificationKeyVersion);
        }
        if (HasVerificationKeyId)
        {
            output.WriteRawTag(34);
            output.WriteString(VerificationKeyId);
        }
        if (HasSignatureAlgorithm)
        {
            output.WriteRawTag(42);
            output.WriteString(SignatureAlgorithm);
        }
        if (_unknownFields != null)
        {
            _unknownFields.WriteTo(ref output);
        }
    }
#endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize()
    {
        int size = 0;
        if (HasVerificationKeyVersion)
        {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(VerificationKeyVersion);
        }
        if (HasVerificationKeyId)
        {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(VerificationKeyId);
        }
        if (HasSignatureAlgorithm)
        {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(SignatureAlgorithm);
        }
        if (_unknownFields != null)
        {
            size += _unknownFields.CalculateSize();
        }
        return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SignatureInfo other)
    {
        if (other == null)
        {
            return;
        }
        if (other.HasVerificationKeyVersion)
        {
            VerificationKeyVersion = other.VerificationKeyVersion;
        }
        if (other.HasVerificationKeyId)
        {
            VerificationKeyId = other.VerificationKeyId;
        }
        if (other.HasSignatureAlgorithm)
        {
            SignatureAlgorithm = other.SignatureAlgorithm;
        }
        _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input)
    {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        input.ReadRawMessage(this);
#else
    uint tag;
    while ((tag = input.ReadTag()) != 0) {
      switch(tag) {
        default:
          _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
          break;
        case 26: {
          VerificationKeyVersion = input.ReadString();
          break;
        }
        case 34: {
          VerificationKeyId = input.ReadString();
          break;
        }
        case 42: {
          SignatureAlgorithm = input.ReadString();
          break;
        }
      }
    }
#endif
    }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input)
    {
        uint tag;
        while ((tag = input.ReadTag()) != 0)
        {
            switch (tag)
            {
                default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                case 26:
                    {
                        VerificationKeyVersion = input.ReadString();
                        break;
                    }
                case 34:
                    {
                        VerificationKeyId = input.ReadString();
                        break;
                    }
                case 42:
                    {
                        SignatureAlgorithm = input.ReadString();
                        break;
                    }
            }
        }
    }
#endif

}

public sealed partial class TemporaryExposureKey : pb::IMessage<TemporaryExposureKey>
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    , pb::IBufferMessage
#endif
{
    private static readonly pb::MessageParser<TemporaryExposureKey> _parser = new pb::MessageParser<TemporaryExposureKey>(() => new TemporaryExposureKey());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TemporaryExposureKey> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor
    {
        get { return global::TestReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor
    {
        get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TemporaryExposureKey()
    {
        OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TemporaryExposureKey(TemporaryExposureKey other) : this()
    {
        _hasBits0 = other._hasBits0;
        keyData_ = other.keyData_;
        transmissionRiskLevel_ = other.transmissionRiskLevel_;
        rollingStartIntervalNumber_ = other.rollingStartIntervalNumber_;
        rollingPeriod_ = other.rollingPeriod_;
        reportType_ = other.reportType_;
        daysSinceOnsetOfSymptoms_ = other.daysSinceOnsetOfSymptoms_;
        _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TemporaryExposureKey Clone()
    {
        return new TemporaryExposureKey(this);
    }

    /// <summary>Field number for the "key_data" field.</summary>
    public const int KeyDataFieldNumber = 1;
    private readonly static pb::ByteString KeyDataDefaultValue = pb::ByteString.Empty;

    private pb::ByteString keyData_;
    /// <summary>
    /// Temporary exposure key for an infected user.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString KeyData
    {
        get { return keyData_ ?? KeyDataDefaultValue; }
        set
        {
            keyData_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        }
    }
    /// <summary>Gets whether the "key_data" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasKeyData
    {
        get { return keyData_ != null; }
    }
    /// <summary>Clears the value of the "key_data" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearKeyData()
    {
        keyData_ = null;
    }

    /// <summary>Field number for the "transmission_risk_level" field.</summary>
    public const int TransmissionRiskLevelFieldNumber = 2;
    private readonly static int TransmissionRiskLevelDefaultValue = 0;

    private int transmissionRiskLevel_;
    /// <summary>
    /// Varying risk associated with a key depending on diagnosis method. 
    /// Deprecated and no longer used.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int TransmissionRiskLevel
    {
        get { if ((_hasBits0 & 1) != 0) { return transmissionRiskLevel_; } else { return TransmissionRiskLevelDefaultValue; } }
        set
        {
            _hasBits0 |= 1;
            transmissionRiskLevel_ = value;
        }
    }
    /// <summary>Gets whether the "transmission_risk_level" field is set</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasTransmissionRiskLevel
    {
        get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "transmission_risk_level" field</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearTransmissionRiskLevel()
    {
        _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "rolling_start_interval_number" field.</summary>
    public const int RollingStartIntervalNumberFieldNumber = 3;
    private readonly static int RollingStartIntervalNumberDefaultValue = 0;

    private int rollingStartIntervalNumber_;
    /// <summary>
    /// The interval number since epoch for which a key starts
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int RollingStartIntervalNumber
    {
        get { if ((_hasBits0 & 2) != 0) { return rollingStartIntervalNumber_; } else { return RollingStartIntervalNumberDefaultValue; } }
        set
        {
            _hasBits0 |= 2;
            rollingStartIntervalNumber_ = value;
        }
    }
    /// <summary>Gets whether the "rolling_start_interval_number" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasRollingStartIntervalNumber
    {
        get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "rolling_start_interval_number" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearRollingStartIntervalNumber()
    {
        _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "rolling_period" field.</summary>
    public const int RollingPeriodFieldNumber = 4;
    private readonly static int RollingPeriodDefaultValue = 144;

    private int rollingPeriod_;
    /// <summary>
    /// How long this key is valid, specified in increments of 10 minutes
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int RollingPeriod
    {
        get { if ((_hasBits0 & 4) != 0) { return rollingPeriod_; } else { return RollingPeriodDefaultValue; } }
        set
        {
            _hasBits0 |= 4;
            rollingPeriod_ = value;
        }
    }
    /// <summary>Gets whether the "rolling_period" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasRollingPeriod
    {
        get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "rolling_period" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearRollingPeriod()
    {
        _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "report_type" field.</summary>
    public const int ReportTypeFieldNumber = 5;
    private readonly static global::TemporaryExposureKey.Types.ReportType ReportTypeDefaultValue = global::TemporaryExposureKey.Types.ReportType.Unknown;

    private global::TemporaryExposureKey.Types.ReportType reportType_;
    /// <summary>
    /// Type of diagnosis associated with a key.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::TemporaryExposureKey.Types.ReportType ReportType
    {
        get { if ((_hasBits0 & 8) != 0) { return reportType_; } else { return ReportTypeDefaultValue; } }
        set
        {
            _hasBits0 |= 8;
            reportType_ = value;
        }
    }
    /// <summary>Gets whether the "report_type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasReportType
    {
        get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "report_type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearReportType()
    {
        _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "days_since_onset_of_symptoms" field.</summary>
    public const int DaysSinceOnsetOfSymptomsFieldNumber = 6;
    private readonly static int DaysSinceOnsetOfSymptomsDefaultValue = 0;

    private int daysSinceOnsetOfSymptoms_;
    /// <summary>
    /// Number of days elapsed between symptom onset and the TEK being used.
    /// E.g. 2 means TEK is from 2 days after onset of symptoms.
    /// Valid values range is from -14 to 14.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int DaysSinceOnsetOfSymptoms
    {
        get { if ((_hasBits0 & 16) != 0) { return daysSinceOnsetOfSymptoms_; } else { return DaysSinceOnsetOfSymptomsDefaultValue; } }
        set
        {
            _hasBits0 |= 16;
            daysSinceOnsetOfSymptoms_ = value;
        }
    }
    /// <summary>Gets whether the "days_since_onset_of_symptoms" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasDaysSinceOnsetOfSymptoms
    {
        get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "days_since_onset_of_symptoms" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearDaysSinceOnsetOfSymptoms()
    {
        _hasBits0 &= ~16;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other)
    {
        return Equals(other as TemporaryExposureKey);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TemporaryExposureKey other)
    {
        if (ReferenceEquals(other, null))
        {
            return false;
        }
        if (ReferenceEquals(other, this))
        {
            return true;
        }
        if (KeyData != other.KeyData) return false;
        if (TransmissionRiskLevel != other.TransmissionRiskLevel) return false;
        if (RollingStartIntervalNumber != other.RollingStartIntervalNumber) return false;
        if (RollingPeriod != other.RollingPeriod) return false;
        if (ReportType != other.ReportType) return false;
        if (DaysSinceOnsetOfSymptoms != other.DaysSinceOnsetOfSymptoms) return false;
        return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode()
    {
        int hash = 1;
        if (HasKeyData) hash ^= KeyData.GetHashCode();
        if (HasTransmissionRiskLevel) hash ^= TransmissionRiskLevel.GetHashCode();
        if (HasRollingStartIntervalNumber) hash ^= RollingStartIntervalNumber.GetHashCode();
        if (HasRollingPeriod) hash ^= RollingPeriod.GetHashCode();
        if (HasReportType) hash ^= ReportType.GetHashCode();
        if (HasDaysSinceOnsetOfSymptoms) hash ^= DaysSinceOnsetOfSymptoms.GetHashCode();
        if (_unknownFields != null)
        {
            hash ^= _unknownFields.GetHashCode();
        }
        return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString()
    {
        return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output)
    {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        output.WriteRawMessage(this);
#else
    if (HasKeyData) {
      output.WriteRawTag(10);
      output.WriteBytes(KeyData);
    }
    if (HasTransmissionRiskLevel) {
      output.WriteRawTag(16);
      output.WriteInt32(TransmissionRiskLevel);
    }
    if (HasRollingStartIntervalNumber) {
      output.WriteRawTag(24);
      output.WriteInt32(RollingStartIntervalNumber);
    }
    if (HasRollingPeriod) {
      output.WriteRawTag(32);
      output.WriteInt32(RollingPeriod);
    }
    if (HasReportType) {
      output.WriteRawTag(40);
      output.WriteEnum((int) ReportType);
    }
    if (HasDaysSinceOnsetOfSymptoms) {
      output.WriteRawTag(48);
      output.WriteSInt32(DaysSinceOnsetOfSymptoms);
    }
    if (_unknownFields != null) {
      _unknownFields.WriteTo(output);
    }
#endif
    }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output)
    {
        if (HasKeyData)
        {
            output.WriteRawTag(10);
            output.WriteBytes(KeyData);
        }
        if (HasTransmissionRiskLevel)
        {
            output.WriteRawTag(16);
            output.WriteInt32(TransmissionRiskLevel);
        }
        if (HasRollingStartIntervalNumber)
        {
            output.WriteRawTag(24);
            output.WriteInt32(RollingStartIntervalNumber);
        }
        if (HasRollingPeriod)
        {
            output.WriteRawTag(32);
            output.WriteInt32(RollingPeriod);
        }
        if (HasReportType)
        {
            output.WriteRawTag(40);
            output.WriteEnum((int)ReportType);
        }
        if (HasDaysSinceOnsetOfSymptoms)
        {
            output.WriteRawTag(48);
            output.WriteSInt32(DaysSinceOnsetOfSymptoms);
        }
        if (_unknownFields != null)
        {
            _unknownFields.WriteTo(ref output);
        }
    }
#endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize()
    {
        int size = 0;
        if (HasKeyData)
        {
            size += 1 + pb::CodedOutputStream.ComputeBytesSize(KeyData);
        }
        if (HasTransmissionRiskLevel)
        {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(TransmissionRiskLevel);
        }
        if (HasRollingStartIntervalNumber)
        {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(RollingStartIntervalNumber);
        }
        if (HasRollingPeriod)
        {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(RollingPeriod);
        }
        if (HasReportType)
        {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int)ReportType);
        }
        if (HasDaysSinceOnsetOfSymptoms)
        {
            size += 1 + pb::CodedOutputStream.ComputeSInt32Size(DaysSinceOnsetOfSymptoms);
        }
        if (_unknownFields != null)
        {
            size += _unknownFields.CalculateSize();
        }
        return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TemporaryExposureKey other)
    {
        if (other == null)
        {
            return;
        }
        if (other.HasKeyData)
        {
            KeyData = other.KeyData;
        }
        if (other.HasTransmissionRiskLevel)
        {
            TransmissionRiskLevel = other.TransmissionRiskLevel;
        }
        if (other.HasRollingStartIntervalNumber)
        {
            RollingStartIntervalNumber = other.RollingStartIntervalNumber;
        }
        if (other.HasRollingPeriod)
        {
            RollingPeriod = other.RollingPeriod;
        }
        if (other.HasReportType)
        {
            ReportType = other.ReportType;
        }
        if (other.HasDaysSinceOnsetOfSymptoms)
        {
            DaysSinceOnsetOfSymptoms = other.DaysSinceOnsetOfSymptoms;
        }
        _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input)
    {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        input.ReadRawMessage(this);
#else
    uint tag;
    while ((tag = input.ReadTag()) != 0) {
      switch(tag) {
        default:
          _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
          break;
        case 10: {
          KeyData = input.ReadBytes();
          break;
        }
        case 16: {
          TransmissionRiskLevel = input.ReadInt32();
          break;
        }
        case 24: {
          RollingStartIntervalNumber = input.ReadInt32();
          break;
        }
        case 32: {
          RollingPeriod = input.ReadInt32();
          break;
        }
        case 40: {
          ReportType = (global::TemporaryExposureKey.Types.ReportType) input.ReadEnum();
          break;
        }
        case 48: {
          DaysSinceOnsetOfSymptoms = input.ReadSInt32();
          break;
        }
      }
    }
#endif
    }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input)
    {
        uint tag;
        while ((tag = input.ReadTag()) != 0)
        {
            switch (tag)
            {
                default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                case 10:
                    {
                        KeyData = input.ReadBytes();
                        break;
                    }
                case 16:
                    {
                        TransmissionRiskLevel = input.ReadInt32();
                        break;
                    }
                case 24:
                    {
                        RollingStartIntervalNumber = input.ReadInt32();
                        break;
                    }
                case 32:
                    {
                        RollingPeriod = input.ReadInt32();
                        break;
                    }
                case 40:
                    {
                        ReportType = (global::TemporaryExposureKey.Types.ReportType)input.ReadEnum();
                        break;
                    }
                case 48:
                    {
                        DaysSinceOnsetOfSymptoms = input.ReadSInt32();
                        break;
                    }
            }
        }
    }
#endif

    #region Nested types
    /// <summary>Container for nested types declared in the TemporaryExposureKey message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types
    {
        /// <summary>
        /// Data type that represents why this key was published.
        /// </summary>
        public enum ReportType
        {
            /// <summary>
            /// Never returned by the client API.
            /// </summary>
            [pbr::OriginalName("UNKNOWN")] Unknown = 0,
            [pbr::OriginalName("CONFIRMED_TEST")] ConfirmedTest = 1,
            [pbr::OriginalName("CONFIRMED_CLINICAL_DIAGNOSIS")] ConfirmedClinicalDiagnosis = 2,
            [pbr::OriginalName("SELF_REPORT")] SelfReport = 3,
            /// <summary>
            /// Reserved for future use.
            /// </summary>
            [pbr::OriginalName("RECURSIVE")] Recursive = 4,
            /// <summary>
            /// Used to revoke a key, never returned by client API.
            /// </summary>
            [pbr::OriginalName("REVOKED")] Revoked = 5,
        }

    }
    #endregion

}

#endregion


#endregion Designer generated code
